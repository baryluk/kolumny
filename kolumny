#!/usr/bin/python

usage = """kolumny - multifile column oriented line processing engine
Author: Witold Baryluk, 2010, Copyright, BSD license
Version: 1.0, 2010-05-13

Usage: kolumny [options]... inputspec...

options:
	--begin python-code
	       : execute Python code after startup
	--end python-code
	       : execute Python code at shutdown
	--gnuplot_begin gnuplot-code
	       : execute gnuplot code after startup
	--fit fit-expression
	       : perform simplified internal fiting (linear, with weights)
	--gnuplot_plot gnuplot-plot-expressions
	       : plot using gnuplot
	--gnuplot_fit gnuplot-fit-expressions
	       : fit usign gnuplot
	--tmpdir path
	       : use path as temporary directory if needed
	--
	       : end options processing here
TODO:
	--header
	--latex_tabular
	--global-skip N
	--global-grep eregexp
	--global-grep-v eregexp
	--global-sed sed-expression
	--progress-bar
	--global-every N
	--output-field-separator string
	--global-input-field-separator -F regexp
	--check columns

inputspec - one of:
	filespec [skip N] [using usingspec]
	":expression"

filespec - one of:
	"filepath"       : named file
	"-"              : standard input
	"<shell command" : spawn /bin/sh with given command and read stdout
	                   (this can be multiple commands seprated using ';'
	                    or any pipe constructed using | character).
	                    Note: remember about shell escaping rules.
	""               : file from previous inputspec
	
	Note: filepath cannot begin with -, <, #, : or confilict
	      with any keyword like u, using, skip, s.

First element of inputspec (filespec or :expression) can be prefixed
with "#" to disable semantic processing of this file. It will
be not opened, readed, calculated or evaluated in any means.
Still given inputspec need to be syntactically correct.

skip N:           (can be abbrevited to s)
	N - positive integer number of first lines to skip from input

using usingspec:  (can be abbrevited to u)
	usingspec of the form:
		u1[,u2][,u3]...
	
	Each u of the form:
		[[~]varname:=]columnsspec
	
	Where
	
	columnspec one of the form:
		N       : positive integer indicating single column number
		          counting from 1
		L...R   : pair of positive integers indicating vector of
		          columns. L marks first column, R last, inclusive.
		          Note that when using later varname for referencing
		          vector's elements L column will be at index 0,
		          L+1 at index 1, etc (just like Python's arrays).
		(pexpr) : where pexpr is any Python expression. column(x)
		          and valid(x) functions can be used to retrive
		          x'th column (counting from 1), or check if it
		          is valid column number and value there is float.
		          x needs to be expression evaluating to positive
		          integer. column(0) returns line number of the file
		          the being processed file (ignores skip).
	
	varname : unique variable name to store scalar or vector value.
	          It will be converted to floats. In case of
	          Python expression it will store value of this
	          expression. varname should be valid Python identifier.
	
	~       : do not print, only store value in variable varname
	          for further reference.

:expression of the form:
	:[~][varname:=]pexpr
	
	Where
	
	pexpr     : any Python expression to evaluate, and print.
	
	varname   : uniqe variable name to store value of pexpr.
	            varname should be valid Python identifier.
	
	~         : do not print pexpr value as a column

Remark: All inputspec (both filespec and :expressions) entries can be
        intermixed in any order, even in case of forward references of
        variable names. Some options can also be presented in any order,
        but relative order of some options is important (for example
        multiple --begin options will be excuted in given order).

Note: Remember to escape shell meta-characters so they
      will not be interpreted, by your shell.

Examples:

kolumny "file1"

	Will output all columns from file "file1", but will
	ensure they are floats.

kolumny "file1" using 1,4

	Will output 2 columns: column 1 and 4 from file "file1"

kolumny "file1" using 1,~c:=2...8 \\
	":sum(c)"

	Will output 2 columns: column 1 from file "file1",
	and sum of values in columns 2...8.

kolumny \\
	"file1" using a:=1,~c:=3...7 \\
	"file2" s 11 u ~b:=1,d:=2 \\
	"#file3" skip 21 using ~e:=1,g:=2 \\
	"<generate_file.py 44 1.41 | egrep -v '^$'" skip 11 \\
		using h:=4,~cg:=1 \\
	":~check(a==b)" \\
	"#:~check(a==e)" \\
	":~check(a==cg)" \\
	":~check(a==x)" \\
	":S:=sum(c)" \\
	":d+g*h" \\
	":sqrt(d)-c[3]*S" \\
	"file4" skip 11 u ~x:=1,~y:=2,z:=4 \\
	":check(S >= 10)" \\
	":'somestring'" \\
	":1e3*xy" \\
	":4,5,b" \\
	":4,5,c" \\
	":~xy:=x+y" \\
	"file4" skip 11 u 3

	Will output lines of the form:
		a d h S=sum(c) d+g+h sqrt(d)-c[3]*S z True/False \\
		  somestring xy*1e3=1000*(x+y) (4,5,b) \\
		  (4,5,[c1,...]) 3rd-column-of-file4

	Note:
		- multiple columns read at once
		- forward reference of variable "x" in check(a==x).
		- comments using '#'
		- python expressions, including math operations,
		  checks, tuple/array printing
		- not printed columns using ~ both in python
		  expressions and file inputs
		- vector columns like c:=3...7.
		  c[3] means 3+3=6th column from "file1"
		- usage of subcommands to generate data
		  and remove empty lines using grep
		- usage of the same file multiple times

kolumny \\
	--begin 'maximum1=float("-inf")' \\
	--begin 'maximum2=float("-inf")' \\
	"file1" using 1,v1:=4,~v2:=5 \\
	":maximum1=max(maximum1,v1)" \\
	":~maximum2=max(maximum2,v2)" \\
	--end   'print "MAX: %f %f" % (maximum1, maximum2)'

	Will output 3 columns from file "file1" (column 1, 2
	and accumulated maximal value of column 4).
	At the end it will additionally print maximal values
	of the 4th and 5th column.

kolumny \\
	--gnuplot_begin 'set terminal png' \\
	--gnuplot1_begin 'set output "chart1.png"' \\
	--gnuplot2_begin 'set output "chart2.png"' \\
	--gnuplot_begin 'f(x) = k1*x + k2' \\
	--gnuplot_begin 'g(x) = A*x + B' \\
	"file1" using y1a:=3,y2a:=4,~xa:=1 \\
	"file2" using y1b:=3,y2b:=4,xb:=1 \\
	":~check(xa==xb)" \\
	":diff1=y1a-y1b" \\
	":diff2=y2a-y2b" \\
	--gnuplot1_fit ":xa,y1"     'f(x)" via "k1,k2" \\
	--gnuplot2_fit ":xa,diff1"  'g(x)" via "A,B" \\
	--gnuplot1_plot "f(x)" ":xa,y2b" ":xa,y1a" ";" \\
	--gnuplot2_plot ":xa,diff2" title "Data2" "g(x)" title 'Fit2' ";" \\
	--end 'print "A: %f  B: %f " % (A, B)'
	
	Perform some fiting and ploting on multiple files.

kolumny "file.dat" using 1,(column(2)+column(3)+column(4))

	Display 2 columns: 1st same as input, 2nd being
	a sum of column 2, 3 and 4 from input.

kolumny "file.dat" using 1,~c=2...4 \\
	":c[2-2]+c[3-2]+c[4-2]"

	Same as above.

kolumny ":x:=3" ":y+x*100" ":y:=4*z" ":z:=100000"

	Use as small spreadsheet.
	Note that only one line will be printed, and
	expressions can be provided in any order.

Report bug to <baryluk@smp.if.uj.edu.pl>.
"""

import sys
from math import *

import subprocess
#import shlex

vec_sum = lambda a, b: map(lambda (x,y): x + y, zip(a, b))

def check(cond):
	assert cond

def eq(x, y):
	# TODO(baryluk): Make it better.
	return abs(x - y) / (abs(x) + abs(y)) < 1.0e-14

def avg(l):
	# TODO(baryluk): This is not the best method.
	return sum(l) / len(l)

def stddev(l):
	m = avg(l)
	# TODO(baryluk): This is not the best method.
	s = sum(map(lambda x: (x - m)**2, l)) / (len(l)-1)
	return sqrt(s)


# TODO:
#   "" as previous file
#   multiple "-" allowed
#   scanf like format for using (like in gnuplot)
#   different skips for the same file (also "" and "-"
#   negative skip in skip keyword (per file and --global-skip)
#   negative columns in using (per file, and in --global-check)
#   every keyword (per file)
#   grep, sed  keyword (multiple times) (per file and --global-regexp*)
#   input-field-separator keyword (per file)
#   --fit with and without weight, and with errors (initially only linear fiting, then lineary dependend fitting)
#    then functions of coefficients
#  --header to add automatically header with variable names
#  --latex_tabular to generate latex table with header, etc.  (like in data2tex.pl)
#  --gnuplot*
#  support expressions in using like in latex:    x:=($3-$1),   probably better: x:=(l[3]-l[1])
#  --global-skip 19
#  --global-regexp 'FLOAT\s*FLOAT\*FLOAT'        # with predefined macros
#  --global-regexp-v '^\s*(#|$)'
#  --global-check 1,3            # means check 1st and 3rd column in each input file, and assert they are equal
#  --output-field-separator
#  --global-input-field-separator

"""
	Example

	--begin 'vec_diff = lambda a,b: map(lambda (x,y): x-y, zip(a,b))'
	--begin 'maximum = float("-inf")'
	--end 'print maximum'
	--gnuplot_begin 'set terminal png'
	--gnuplot_begin 'set output "plik.png"'
	--gnuplot_begin 'f(x) = k1*x + k2'
	--fit 'a=k1*b+k2'
	--fit 'a \pm a_err = k1 * b \pm b_err + k2'
	--fit 'log(a \pm a_err) = log(k1) * (b \pm b_err)**4 + k2*k2'    // detect that a and b are existing values
												// they need to be on different sides of expression
												// find biggest subexpressions without other unknown variables
												// one of the biggest subexpressions need be entire one side
												// then it must by of the for:   S1 = S2 * A  + B    (1)
												// where A and B are some expressions with exactly one unknown variable
												// find linear fit for (1)
												// inverse expressions for A and B for unknown variables k1, k2
												// calculate derivatives and calculate errors for k1, k2.
																
	--gnuplot_fit 'a:b f(x) via k1,k2'
	--gnuplot_plot 'a:b, c:d'
	"./100324 - Delta - bufor#001.txt" u ~a:=1...8,b:=10...15 \
	"./100324 - Delta - bufor#005.txt" u a1:=1...8 \
	"#./100324 - Delta - bufor#005.txt" u a1:=1...8 \
	"#./100324 - Delta - bufor#006.txt" u a2:=1...8 \
	"<echo 1 2; echo 2 3; echo 6 10" u 2 \
	"#<echo 1 2; echo 2 3; echo 6 10" u 2 \
	"./100324 - Delta - bufor#001.txt" skip 19 u c1=1,f1=2 \
	"./100324 - Delta - bufor#001.txt" u 3 \
	"-" u 3 \
	"-" skip 5 u 6 \
	"./100324 - Delta#003.txt" skip 19 u c2:=1,f2:=2 \
	"./100324 - Delta_HIV#002.txt" skip 19 u f4:=2 \
	"" u 3 \
	"./100324 - Delta_AAV-60#006.txt" skip 19 u 'f7:=(3+column(2)*column(3))' \
	"./100324 - Delta_AAV-60#006.txt" skip 19 u '~f7temp:=2' \
	":f7:=3+f7temp'\
	":f2-f1" \
	":f7-f1" \
	":a[3]-a[2]" \
	":sum(a)" \
	":vec_sum(a1,a2)" \
	":avg(a)" \
	":stddev(a)" \
	":~p:=f5-f1" \
	":p" \
	":r*2.0" \
	":r:=f5-f1" \
	":maximum:=max(maximum,r)"
	":~check(c1 == c2 == c3)"
"""

files = []
variables = {}
functions = {}

actions = []

arguments = sys.argv
argument_i = 1

my_name = arguments[0]

number_of_files = 0

if len(arguments) == 1:
	print usage
	raise NameError("invalid arguments")

while argument_i < len(arguments):
	e = arguments[argument_i]
	argument_i += 1
	action = {}
	commented = False
	# TODO: support file name "" (previous file)
	if e[0] == '#':
		commented = True
		e = e[1:]
	action["commented"] = commented

	if e == "--begin":
		e = arguments[argument_i]
		argument_i += 1
		eval(e, globals())
	elif e == "--import":
		e = arguments[argument_i]
		argument_i += 1
		__import__(e)
	elif e[0] == ':':
		action["type"] = "expression"
		e = e[1:]
		not_print = False
		if e[0] == "~":
			not_print = True
			e = e[1:]
		action["not_print"] = not_print
		if len(e) == 0:
			raise NameError("at most one 'using' allowed")
		action["expression"] = e
		e = e.split(":=")
#		if not_print and len(e) == 1:
#			raise NameError("What is a point calculating something without printing or assigning? '%s'" % (e))
#			# There is a point. It can have side effects, like accumulating something, or assert check.
		action["expression_variable"] = None
		if len(e) == 1:
			action["expression_expr"] = e[0]
		elif len(e) == 2:
			action["expression_variable"] = e[0]
			action["expression_expr"] = e[1]
		else:
			raise NameError("at most one ':=' allowed in expression. '%s'" % (e))
		action["expression_p"] = e
		if (argument_i < len(arguments)) and (arguments[argument_i] == "title"):
			argument_i += 1
			action["title"] = arguments[argument_i]
			argument_i += 1
	else:
		action["type"] = "file"
		action["file_name"] = e # TODO: allow "" for shortcut for previously used filename
		number_of_files += 1
		plik = None
		if e[0] == '<':
			action["file_type"] = "pipe"
			e = e[1:]
			action["pipe_command"] = e
			if not commented:
				try:
					p1 = subprocess.Popen(e, shell=True, close_fds=True, stdout=subprocess.PIPE)
					#plik = popen(e)
					plik = p1.stdout
				except OSError, err:
					print >>sys.stderr, "Execution failed:", err
					raise
		else:
			if e == "-":
				action["file_type"] = "stdin"
				if not commented:
					plik = sys.stdin # TODO: support multiple usage of "-", and ""
			else:
				action["file_type"] = "file"
				if e == "":
					raise NameError("file name \"\" (previously used filename) not supported")
				if not commented:
					plik = file(e)
		action["file"] = plik
		have_using = False
		using = None
		using2 = None
		have_skip = False
		have_title = False
		skip = None
		used = None
		while argument_i < len(arguments):
			next = arguments[argument_i]
			if next == "u" or next == "using":
				argument_i += 1
				if have_using:
					raise NameError("at most one 'using' allowed")
				have_using = True
				using = arguments[argument_i]
				argument_i += 1
				if len(using) == 0:
					raise NameError("empty using not allowed")
				using = using.split(",")
				used = []
				for u in using:
					"""
						4
						($3-412)  # expression: not supported, not neeed
						-5 # 5th column from right: not supported
						1...10 # columns 1...10
						6...-1   # columns 6,7,....,last_columnt

					this can be prefix with:

						v:=     # assign to v, and print
						~v:=    # assign to v, and not print

					for example

						v:=4
						v:=($3-412)  # expression: not supported, not neeed
						v:=-5 # 5th column from right: not supported
						v:=1...10 # columns 1...10    # vector
						v:=6...-1   # columns 6,7,....,last_columnt : not supported     # vector

						~v:=4
						~v:=($3-412)  # expression: not supported, not neeed
						~v:=-5 # 5th column from right: not supported
						~v:=1...10 # columns 1...10    # vector
						~v:=6...-1   # columns 6,7,....,last_columnt: not supported   # vector

					"""
					if len(u) == 0:
						raise NameError("empty specifier not allowed")
					u = u.split(":=")
					if len(u) > 2:
						raise NameError("at most one ':=' allowed in each specifier")
					not_print = False
					var = None
					columns_spec = ""
					if len(u) == 2:
						var = u[0]
						if len(var) == 0:
							raise NameError("variable name before ':=' needed")
						if var[0] == "~":
							not_print = True
							var = var[1:]
						if len(var) == 0:
							raise NameError("variable name before ':=' needed")
						if var in variables:
							raise NameError("variable name '%s' already defined in some previous using" % (var))
						columns_spec = u[1]
					else:
						columns_spec = u[0]
					if len(columns_spec) == 0:
						raise NameError("columns spec needed")
					typ = None
					cc = None
					if columns_spec[0] == "(":
						if columns_spec[-1] != ")":
							raise NameError("opening bracket present, but closing missing")
						typ = "python-expression"
						cc = columns_spec
					else:
						columns_spec = columns_spec.split("...")
						if len(columns_spec) == 0:
							raise NameError("columns spec needed")
						if len(columns_spec) == 1:
							c = columns_spec[0]
							c = int(c)
							if c <= 0:
								raise NameError("positive column number needed currently")
							cc = c
							typ = "scalar"
						elif len(columns_spec) == 2:
							c_left, c_right = columns_spec
							c_left = int(c_left)
							# TODO: support 'length' as c_right
							c_right = int(c_right)
							if c_left > c_right:
								raise NameError("error in columns spec, first column cant be after last column used")
							cc = (c_left, c_right)
							typ = "vector"
						else:
							raise NameError("only zero or one '...' in columns spec allowed")
					variables[var] = {"file": plik, "type": typ, "column": cc}
					used.append({"variable": var, "not_print": not_print, "type": typ, "columns": cc})
			elif next == "t" or next == "title":
				argument_i += 1
				if have_title:
					raise NameError("at most one 'title' allowed")
				have_title = True
				title = arguments[argument_i]
				argument_i += 1
			elif next == "s" or next == "skip":
				argument_i += 1
				if have_skip:
					raise NameError("at most one 'skip' allowed")
				have_skip = True
				skip = arguments[argument_i]
				argument_i += 1
				skip = int(skip)
				# perform actuall skiping
				if skip > 0:
					if not commented:
						i = 0
						while i < skip:
							plik.readline()
							i += 1
				else:
					raise NameError("positive skip needed")
					# TODO: for negative skip, we skip last 'skip' lines
					# we can't generally scan file twice (i.e. stdin), so we can't know how many lines there is
					# so we need to remember skip+1 lines in the memory
			#elif next == "F" or next == "field_separator":
			#elif next == "scanf":
			#
			else:
				break
		action["using"] = using
		action["used"] = used
		action["skip"] = skip
		if have_title:
			action["title"] = title
		action["processed_lines"] = 0
		if skip:
			action["current_line_number"] = skip
		else:
			action["current_line_number"] = 0
	actions.append(action)

def go():
	cols = {}
	current_variables = {}
	line_number = 0

	while True:
		row = []
		line_number += 1
		current_variables = {}
		try:
			# first we will read columns which need to be stored in some variable
			for a in actions:
				if a["commented"]:
					continue
				if a["type"] == "file":
					try:
						l = a["file"].next()
						a["current_line_number"] += 1
						l = l.strip()
						l = l.split()
						a["current_line_array"] = l
						if a["using"]:
							for u in a["used"]:
								var = u["variable"]
								if var:
									if var in current_variables:
										raise NameError("already assigned variable")
									c = u["columns"]
									if u["type"] == "scalar":
										v = float(l[c-1])
										current_variables[var] = v
									elif u["type"] == "vector":
										v = []
										c_left, c_right = c
										for ci in xrange(c_left, c_right+1):
											vi = float(l[ci-1])
											v.append(vi)
										current_variables[var] = v
									elif u["type"] == "python-expression":
										def is_valid_float(x):
											try:
												if i < len(l):
													p = float(l[x-1])
													return True
												else:
													return False
											except:
												return False
										def column_function(x):
											if x == 0:
												return line_number
											else:
												if x > len(l):
													raise NameError("trying to access invalid column number %d in file '%s' line %d, only %d columns available" % (x, a["file_name"], a["current_line_number"], len(l)))
												return float(l[x-1])
										available_locals = {
											"column": column_function,
											"valid": is_valid_float,
										}
										try:
											v = eval(c, globals(), available_locals)
											current_variables[var] = v
										except:
											print >> sys.stderr, "%s: output line %d: error procesing file '%s' when evaluating python-expression '%s' in using in phase1" % (my_name, line_number, a["file_name"], c)
											raise
									else:
										raise NameError("only scalar, vector or python-expression supported in using")
								else:
									pass
					except IndexError:
						print >> sys.stderr, "%s: output line %d: Not existing column in file '%s' line %d in phase1" % (my_name, line_number, a["file_name"], a["current_line_number"])
						raise
					except StopIteration:
						print >> sys.stderr, "%s: output line %d: End of file '%s' line %d in phase1" % (my_name, line_number, a["file_name"], a["current_line_number"])
						# end of file
						raise
					except:
						print >> sys.stderr, "%s: output line %d: Error when procesing file '%s' line %d in phase1" % (my_name, line_number, a["file_name"], a["current_line_number"])
						raise
				elif a["type"] == "expression":
					a["expression_done"] = False
					a["expression_calculated"] = False
					a["expression_value"] = None
					a["expression_position"] = None
		except StopIteration:
			break
		except IndexError:
			break
		
		last_processed_u = None
		
		action_pass = 0
		progress = True
		need_more = True
		need_expr = None
		try:
			while progress and need_more:
				progress = False
				need_more = False
				need_expr = None
				action_pass += 1
				for a in actions:
					if a["commented"]:
						continue
					# second we will read columns which need to be printed
					if a["type"] == "file":
						if action_pass > 1:
							continue
						try:
							l = a["current_line_array"]
							if a["using"]:
								for u in a["used"]:
									if u["not_print"]:
										continue
									else:
										# TODO: if it was stored in variable, just use variable, and not parse again
										c = u["columns"]
										if u["type"] == "scalar":
											v = float(l[c-1])
											row.append(v)
										elif u["type"] == "vector":
											#v = []
											c_left, c_right = c
											for ci in xrange(c_left, c_right+1):
												vi = float(l[ci-1])
												row.append(vi)
										elif u["type"] == "python-expression":
											def is_valid_float(x):
												try:
													if i < len(l):
														p = float(l[x-1])
														return True
													else:
														return False
												except:
													return False
											def column_function(x):
												if x == 0:
													return line_number
												else:
													if x > len(l):
														raise NameError("trying to access invalid column number %d in file '%s' line %d, only %d columns available" % (x, a["file_name"], a["current_line_number"], len(l)))
													return float(l[x-1])
											available_locals = {
												"column": column_function,
												"valid": is_valid_float,
											}
											try:
												v = eval(c, globals(), available_locals)
												row.append(v)
											except:
												print >> sys.stderr, "%s: output line %d: error procesing file '%s' when evaluating python-expression '%s' in using in phase2" % (my_name, line_number, a["file_name"], c)
												raise
										else:
											raise NameError("only scalar, vector or python-expression supported in using")
							else:
								for v in l:
									row.append(v)
						except:
							print >> sys.stderr, "%s: Error when procesing file '%s' line %d in phase2" % (my_name, a["file_name"], a["current_line_number"])
							print >> sys.stderr, "%s: Used using %s" % (my_name, a["used"])
							raise
					elif a["type"] == "expression":
						if a["expression_done"]:
							continue
						last_processed_u = (a["expression_expr"],)
						ec = a["expression_calculated"]
						if not ec:
							expr = a["expression_expr"]
							try:
								v = eval(expr, globals(), current_variables)
							except NameError:
								need_more = True
								need_expr = expr
								continue
							except ValueError:
								v = float("nan")
							var = a["expression_variable"]
							if var:
								if var in current_variables:
									print >> sys.stderr, "already assigned variable '%s'" % (var)
									raise NameError("already assigned")
								else:
									current_variables[var] = v
							a["expression_value"] = v
							ec = True
							a["expression_calculated"] = ec
						else:
							v = a["expression_value"]
						if ec and not a["not_print"] and not need_more:
							row.append(v)
							a["expression_done"] = True
							a["expression_position"] = None
						progress = True
					else:
						raise NameError("only files and :expressions allowed")
		except IndexError:
			break
		except:
			print >> sys.stderr, "Exception occured when processing output line %d at phase2, pass number %d: '%s'" % (line_number, action_pass, last_processed_u)
			raise
		
		if need_more and not progress:
			print >> sys.stderr, "Unresolved dependency in expression '%s'" % (need_expr)
			raise NameError("unresolved dependencies in variable")
		
		# emit row with values to be printed
		yield row
		
		# in case of no input files and just python-expressions
		# do not loop, and just print single row.
		if number_of_files == 0:
			return

# create iterator
kk = go()

# traverse iterator
for row in kk:
	for c in row:
		print c,
	print
